# *****************************************************************************
# * Copyright by ams OSRAM AG                                                 *
# * All rights are reserved.                                                  *
# *                                                                           *
# *FOR FULL LICENSE TEXT SEE LICENSES-MIT.TXT                                 *
# *****************************************************************************
"""
This class allows to read and write registers or register+block
"""

import ctypes


class RegisterIo:    
    """Class that handles register read, register write, and register print.
       Uses IcCom for communication."""
       
    LOG_NONE = 0
    LOG_INFO = 1        # only print register info, no fifo, no block read
    LOG_VERBOSE = 10

    def __init__(self,ic_com,dev_addr:int=-1,log_level:int=LOG_INFO,i2c_print:bool=False,addr_width_in_bytes:int=1):
        pass


def ctypes2Dict(frame):
    """To convert a simple ctypes frame into a dictionary call this function. this is a recursive function.
    Args:
        frame: a ctpye structure/list
    """
    # if the type is not a primitive and it evaluates to False ...
    if (type(frame) not in [int, float, bool]) and not bool(frame):
        # it's a null pointer
        return 0
    elif (type(frame) in [int, float, bool]):
        return frame
    elif hasattr(frame, "_length_") and hasattr(frame, "_type_"):
        # Probably an array
        return list(map(ctypes2Dict, frame))
    elif hasattr(frame, "_fields_"):
        result = {}
        for temp in frame._fields_:
            field = temp[0]
            v = getattr(frame, field)
            result[field] = ctypes2Dict(v)
        return result
    return None

def dict2Ctypes(struct_type, values):
    """Convert a dictionary back to a ctypes Structure/Array.

    Args:
        struct_type (class): The data type to be filled. Must be of base class ctypes.Structure|ctypes.Array.
        values (dict|array): The dictionary or array which was previously generated by ctypes2Dict().
    Returns: 
        struct_type: A ctypes instance with the data from the dictionary.
        
    Example::

        class DummyStructure(ctypes.LittleEndianStructure):
            _pack_ = 1
            _fields_ = [ 
                ("bitfield1", ctypes.c_uint8, 1),
                ("bitfield2", ctypes.c_uint8, 7),
                ("array", ctypes.c_uint8*6),
                ]
        data = DummyStructure()
        data.bitfield1 = 1
        data.bitfield2 = 23
        data.array = (ctypes.c_uint8*6)(*range(6))
        print([hex(x) for x in bytes(data)])
        data_dict = ctypes2Dict(data)
        print(data_dict)
        data_recovered = dict2Ctypes(DummyStructure, data_dict)
        print([hex(x) for x in bytes(data_recovered)])
    """
    def _dict2Ctypes(dst, value):
        """ A helper function to pass the ctypes instance by reference. Is called recursively."""
        if type(value) is list:
            assert hasattr(dst, "_length_")
            for i, v in enumerate(value):
                if type(v) in [int, float, bool]:
                    dst[i] = v
                else:
                    _dict2Ctypes(dst[i], v)
        elif type(value) is dict:
            for field_name in value:
                v = value[field_name]
                if type(v) in [int, float, bool]:
                    assert hasattr(dst, field_name)
                    setattr(dst, field_name, v)
                else:
                    _dict2Ctypes(getattr(dst, field_name), v)
        else:
            assert False, "Types other than lists or structs are not allowed."
        pass
    res = struct_type()
    _dict2Ctypes(res, values)
    return res

